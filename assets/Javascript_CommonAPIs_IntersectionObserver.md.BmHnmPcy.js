import{_ as s,c as a,o as e,a4 as n}from"./chunks/framework.B3h3aO-h.js";const v=JSON.parse('{"title":"IntersectionObserver","description":"","frontmatter":{},"headers":[],"relativePath":"Javascript/CommonAPIs/IntersectionObserver.md","filePath":"Javascript/CommonAPIs/IntersectionObserver.md","lastUpdated":1717098301000}'),t={name:"Javascript/CommonAPIs/IntersectionObserver.md"},i=n(`<h1 id="intersectionobserver" tabindex="-1">IntersectionObserver <a class="header-anchor" href="#intersectionobserver" aria-label="Permalink to &quot;IntersectionObserver&quot;">​</a></h1><p>Intersection Observer API 为开发者提供了一种可以异步监听目标元素与其祖先或者视窗（viewport）交叉状态的手段。主要场景<strong>懒加载和无限滚动</strong></p><h2 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const observer = new IntersectionObserver(callback, options)</span></span>
<span class="line"><span>observer.observe(target)</span></span></code></pre></div><h2 id="callback-参数" tabindex="-1">callback 参数 <a class="header-anchor" href="#callback-参数" aria-label="Permalink to &quot;callback 参数&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>callback([IntersetionObserverEntry],options)</span></span></code></pre></div><h3 id="intersectionobserverentry对象" tabindex="-1">IntersectionObserverEntry对象 <a class="header-anchor" href="#intersectionobserverentry对象" aria-label="Permalink to &quot;IntersectionObserverEntry对象&quot;">​</a></h3><ul><li>time 返回一个记录从IntersectionObserver开始实例化的时间到交叉状态发生改变的时间的时间戳对比时间</li><li>rootBounds 根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null</li><li>boundingClientRect 目标元素的矩形信息</li><li>isIntersecting 目标元素当前是否可见 Boolean值 可见为true</li><li>intersectionRect 目标元素与视口（或root根元素）的交叉区域的信息</li><li>intersectionRatio 标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全交叉时为1，完全不交叉时小于等于0</li><li>target 被观察的目标元素，是一个 DOM 节点对象</li><li>isVisible trackVisibility开启后生效,被遮挡或者透明时为false</li></ul><h3 id="options" tabindex="-1">options <a class="header-anchor" href="#options" aria-label="Permalink to &quot;options&quot;">​</a></h3><ul><li>delay 延迟时间,单位毫秒</li><li>root 默认是窗口,可以设置具体dom</li><li>rootMargin 默认&quot;0px 0px 0px 0px&quot; 可以扩大窗口大小</li><li>scrollMargin 默认&quot;0px 0px 0px 0px&quot; 可以减少滚动距离target的交叉轴的距离</li><li>thresholds 跟踪阈值</li><li>trackVisibility 轨迹可见性 需要伴随delay</li></ul><h2 id="快速实现懒加载" tabindex="-1">快速实现懒加载 <a class="header-anchor" href="#快速实现懒加载" aria-label="Permalink to &quot;快速实现懒加载&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const io = new IntersectionObserver(callback);</span></span>
<span class="line"><span>let imgs = document.querySelectorAll(&quot;[data-src]&quot;); // 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src</span></span>
<span class="line"><span>function callback(entries) {</span></span>
<span class="line"><span>    entries.forEach((item) =&gt; {</span></span>
<span class="line"><span>        // 遍历entries数组</span></span>
<span class="line"><span>        if (item.isIntersecting) {</span></span>
<span class="line"><span>        // // 当前元素可见</span></span>
<span class="line"><span>        item.target.src = item.target.dataset.src; // 替换src</span></span>
<span class="line"><span>        io.unobserve(item.target); // 停止观察当前元素 避免不可见时候再次调用callback函数</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// io.observe接受一个DOM元素，添加多个监听 使用forEach</span></span>
<span class="line"><span>imgs.forEach((item) =&gt; {</span></span>
<span class="line"><span>    io.observe(item);</span></span>
<span class="line"><span>});</span></span></code></pre></div>`,12),r=[i];function l(o,c,p,d,b,h){return e(),a("div",null,r)}const g=s(t,[["render",l]]);export{v as __pageData,g as default};
